function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

var React = require('react');

var PropTypes = require('prop-types');

var DefaultCanvasSize = 16;
var linkElements = [];

var drawAlert = function drawAlert(context, _ref) {
  var fillColor = _ref.fillColor,
      text = _ref.text,
      textColor = _ref.textColor,
      canvasSize = _ref.canvasSize;
  var Padding = canvasSize / 5;
  context.font = "bold " + (canvasSize - Padding * 2) + "px arial";
  var w = Math.min(context.measureText(text).width, canvasSize - Padding) + Padding;
  var x = canvasSize - w;
  var y = canvasSize / 2 - Padding;
  var h = Padding + canvasSize / 2;
  var r = Math.min(w / 2, h / 2);
  context.beginPath();
  context.moveTo(x + r, y);
  context.arcTo(x + w, y, x + w, y + h, r);
  context.arcTo(x + w, y + h, x, y + h, r);
  context.arcTo(x, y + h, x, y, r);
  context.arcTo(x, y, x + w, y, r);
  context.closePath();
  context.fillStyle = fillColor;
  context.fill();
  context.fillStyle = textColor;
  context.textBaseline = 'bottom';
  context.textAlign = 'right';
  context.fillText(text, canvasSize - Padding / 2, canvasSize, canvasSize - Padding);
};

function drawIcon(_ref2) {
  var alertCount = _ref2.alertCount,
      alertFillColor = _ref2.alertFillColor,
      alertTextColor = _ref2.alertTextColor,
      callback = _ref2.callback,
      renderOverlay = _ref2.renderOverlay,
      src = _ref2.url,
      canvasSize = _ref2.canvasSize;
  var img = document.createElement('img');
  img.crossOrigin = 'Anonymous';

  img.onload = function () {
    var canvas = document.createElement('canvas');
    canvas.width = canvasSize;
    canvas.height = canvasSize;
    var context = canvas.getContext('2d');
    context.clearRect(0, 0, img.width, img.height);
    context.drawImage(img, 0, 0, canvas.width, canvas.height);

    if (alertCount) {
      drawAlert(context, {
        fillColor: alertFillColor,
        textColor: alertTextColor,
        text: alertCount,
        canvasSize: canvasSize
      });
    }

    if (renderOverlay) {
      renderOverlay(canvas, context);
    }

    callback(context.canvas.toDataURL());
  };

  img.src = src;
}

var Favicon = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Favicon, _React$Component);

  function Favicon() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      animationIndex: 0,
      animationLoop: null,
      animationRunning: false
    };
    return _this;
  }

  Favicon.getActiveInstance = function getActiveInstance() {
    return Favicon.mountedInstances[Favicon.mountedInstances.length - 1];
  };

  Favicon.draw = function draw() {
    if (typeof document === 'undefined') return;
    var activeInstance = Favicon.getActiveInstance();

    if (linkElements.length === 0) {
      var head = document.getElementsByTagName('head')[0];
      var linkEl = document.createElement('link');
      linkEl.type = 'image/x-icon';
      linkEl.rel = 'icon';
      var linkApple = document.createElement('link');
      linkApple.rel = 'apple-touch-icon';
      linkElements.push(linkEl, linkApple);
      var links = head.getElementsByTagName('link');

      for (var i = links.length; --i >= 0;) {
        if (/\bicon\b/i.test(links[i].getAttribute('rel')) && !activeInstance.props.keepIconLink(links[i])) {
          head.removeChild(links[i]);
        }
      }

      linkElements.forEach(function (el) {
        return head.appendChild(el);
      });
    }

    var currentUrl;

    if (activeInstance.props.url instanceof Array) {
      currentUrl = activeInstance.props.url[activeInstance.state.animationIndex];
    } else {
      currentUrl = activeInstance.props.url;
    }

    if (activeInstance.props.alertCount || activeInstance.props.renderOverlay) {
      drawIcon({
        alertCount: activeInstance.props.alertCount,
        alertFillColor: activeInstance.props.alertFillColor,
        alertTextColor: activeInstance.props.alertTextColor,
        callback: function callback(url) {
          linkElements.forEach(function (el) {
            return el.href = url;
          });
        },
        renderOverlay: activeInstance.props.renderOverlay,
        url: currentUrl,
        canvasSize: activeInstance.props.iconSize
      });
    } else {
      linkElements.forEach(function (el) {
        return el.href = currentUrl;
      });
    }
  };

  Favicon.update = function update() {
    if (typeof document === 'undefined') return;
    var activeInstance = Favicon.getActiveInstance();
    var isAnimated = activeInstance.props.url instanceof Array && activeInstance.props.animated;
    var intervalId = null;
    clearInterval(activeInstance.state.animationLoop);

    if (isAnimated) {
      var animateFavicon = function animateFavicon() {
        var nextAnimationIndex = (activeInstance.state.animationIndex + 1) % activeInstance.props.url.length;
        Favicon.draw();
        activeInstance.setState({
          animationIndex: nextAnimationIndex
        });
      };

      intervalId = setInterval(animateFavicon, activeInstance.props.animationDelay);
      animateFavicon();
    } else {
      Favicon.draw();
    }

    activeInstance.setState({
      animationLoop: intervalId
    });
  };

  var _proto = Favicon.prototype;

  _proto.componentDidMount = function componentDidMount() {
    Favicon.mountedInstances.push(this);
    Favicon.update();
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    var activeInstance = Favicon.getActiveInstance();
    clearInterval(activeInstance.state.animationLoop);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (prevProps.url === this.props.url && prevProps.animated === this.props.animated && prevProps.alertCount === this.props.alertCount && prevProps.alertFillColor === this.props.alertFillColor && prevProps.alertTextColor === this.props.alertTextColor && prevProps.renderOverlay === this.props.renderOverlay && prevProps.keepIconLink === this.props.keepIconLink && prevProps.iconSize === this.props.iconSize) return;
    Favicon.update();
  };

  _proto.render = function render() {
    return null;
  };

  return Favicon;
}(React.Component);

Favicon.displayName = 'Favicon';
Favicon.mountedInstances = [];
Favicon.defaultProps = {
  iconSize: DefaultCanvasSize,
  alertCount: null,
  alertFillColor: 'red',
  alertTextColor: 'white',
  animated: true,
  animationDelay: 500,
  keepIconLink: function keepIconLink() {
    return false;
  },
  renderOverlay: null,
  url: null
};
Favicon.propTypes = {
  iconSize: PropTypes.number,
  alertCount: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  alertFillColor: PropTypes.string,
  alertTextColor: PropTypes.string,
  animated: PropTypes.bool,
  animationDelay: PropTypes.number,
  keepIconLink: PropTypes.func,
  renderOverlay: PropTypes.func,
  url: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.string]).isRequired
};
module.exports = Favicon;
//# sourceMappingURL=index.js.map
